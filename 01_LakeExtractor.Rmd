---
title: "01_PullMunge"
author: "Simon Topp"
date: "6/29/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(tidyverse)
library(lubridate)
library(purrr)
library(furrr)
library(data.table)
library(feather)
library(sf)

source('00_Functions.R')
knitr::opts_chunk$set(echo = TRUE)
```

## Read in the data and aggregate some initial stats to see how many observations
we pulled.

```{r eval = F}
files <- list.files('data/raw', full.names = T)
files <- files[file.size(files) > 1] ## 6 WRS tile returned no values

## Just look how many obs per lake we're getting  
pullStats <- function(file){
  df <- read_csv(file) %>%
    group_by(Hylak_id) %>%
    summarize(count = n())
  return(df)
}

## Do it all in parallel because it takes awhile with ~30 million obs
plan(multiprocess)
stats <- files %>% future_map_dfr(pullStats, .progress = T)
plan(sequential)

stats.agg <- stats %>%
  group_by(Hylak_id) %>%
  summarize(tile.count = n(),
            obs = sum(count))

meanObs <- mean(stats.agg$obs)
medObs <- median(stats.agg$obs)
```

# Looks like we have a mean of `r meanObs` observations and median of `r medObs` obeservations per lake in hydrolakes

```{r}
ggplot(stats.agg, aes(x = obs, fill = factor(tile.count))) + 
  geom_histogram() + 
  scale_fill_viridis_d() +
  theme_bw() +
  labs()
```

## Do a conservative munge on the dataset to reduce the noise

```{r eval = F}
## Munge it conservatively, basically no hillshade, zero clouds/shadow/ice and
## at least 8 pixels
## at the same time extract the date and Landsat ID to join with the metadata
munger <- function(file){
  df <- read_csv(file) %>%
    filter(!is.na(Blue),
           hillShadow == 1,
           cScore_clouds == 0,
           pCount_dswe1 > 8) %>%
    mutate(LandsatID = map_chr(`system:index`, ~str_split(.,'_0000')[[1]][1]),
         date =  map_chr(LandsatID, ~tail(strsplit(., "_")[[1]], n =1)),
         date = ymd(date)) %>%
  select(-`system:index`)
  return(df)
}

## Again, do it all in Parallel
plan(multiprocess)
munged <- files %>% future_map_dfr(munger, .progress = T)
plan(sequential)

## Save the output
write_csv(munged, 'data/sr_us_hydrolakes_dp_20200628.csv')
write_feather(munged, 'data/sr_us_hydrolakes_dp_20200628.feather')
```


```{r}
munged <- read_feather('data/processed/sr_us_hydrolakes_dp_20200628.feather')
## Look at new post-munged values
summary <- setDT(munged)[,.N,.(Hylak_id)]

postMungeMean <- mean(summary$N)
postMungeMed <- median(summary$N)

ggplot(summary, aes(x = N)) + 
  geom_histogram() +
  geom_vline(aes(xintercept = postMungeMean)) +
  theme_bw() +
  labs(title = '~22.3 Million Obs over 57k Lakes with an Average of 392 Obs per lake')
```

# After munging, we have  a mean of `r postMungeMean` observations and median of `r postMungeMed` obeservations per lake in hydrolakes.  Now join the data to the metadata and look at potential biases between sensors.

```{r}
meta <- read_csv('data/SceneMetadata.csv')
meta <- meta %>% rename(LandsatID = `system:index`)

refCompPre <- munged %>%
  left_join(meta %>% select(LandsatID, sat = SATELLITE)) %>%
  select(LandsatID, Hylak_id, date, Blue, Red, Green, Nir, TIR1, sat, pCount_dswe1, pCount_dswe3) 

refCompPre <- as.data.table(refCompPre)[, year := year(date)
               ][, week := week(date)
                 ][, month := month(date)
                   ][,period :=cut(year, 6)
                    ][,dWLPre := fui.hue(Red, Green, Blue)
                     ][,sat := factor(sat, levels = c('LANDSAT_5','LANDSAT_7','LANDSAT_8'),
                      labels = c('l5','l7','l8'))]


refCompPre <- refCompPre %>% sample_frac(.2)

lm8 <- function(band){
  y <- refCompPre %>% 
    filter(year > 2012, sat == 'l7') %>% 
    .[,band] %>% 
    quantile(., seq(.01,.99, .01))
  
  x = refCompPre %>% 
    filter(year > 2012, sat == 'l8') %>% 
    .[,band] %>% 
    quantile(., seq(.01,.99, .01))
  
  lm <- lm(y~poly(x, 2, raw = T))
  
  df <- tibble(band = band, intercept = lm$coefficients[[1]], B1 = lm$coefficients[[2]], B2 = lm$coefficients[[3]])

  return(df)
}

lm5 <- function(band){
  y <- refCompPre %>% 
    filter(year > 1999, year < 2012, sat == 'l7') %>% 
    .[,band] %>% 
    quantile(., seq(.01,.99, .01))
  
  x = refCompPre %>% 
    filter(year > 1999, year < 2012, sat == 'l5') %>% 
    .[,band] %>% 
    quantile(., seq(.01,.99, .01))
  
  lm <- lm(y~poly(x, 2, raw = T))
  
  df <- tibble(band = band, intercept = lm$coefficients[[1]], B1 = lm$coefficients[[2]], B2 = lm$coefficients[[3]])

  return(df)
}


## Create the functions and look at the resulting corrections
bands <-  c('Blue', 'Green', 'Nir', 'Red', 'TIR1')
funcs.8 <- bands %>% map_dfr(lm8)
funcs.5 <- bands %>% map_dfr(lm5)
# 
# funcs.5 <- bands %>%
#   mutate(lm5 = purrr::map(band, lm5, x = refCompPre))

funcs.5 %>% mutate(SatCor = 'l5') %>%
  bind_rows(funcs.8 %>% mutate(SatCor = 'l8')) %>%
  write_feather(.,'data/out/landsat_correction_coefficients.feather')

write_feather(refCompPre, 'data/srMunged_Original_us_hydrolakes_dp_20200628.feather')
```

## We know from previous work that even minor differences between sensors can translate to meaningful differences in dominant wavelength, so we'll apply the above corrections to the entire dataset

```{r}
## Not sure how to do if else statemtns with data.table, so we'll put it in parallel
## and map it

l5corr <- refCompPre[sat == 'l5'
                     ][,Blue := funcs.5[1,2][[1]] +
                                      funcs.5[1,3][[1]]*Blue +
                                      funcs.5[1,4][[1]]*Blue^2
                       ][,Green := funcs.5[2,2][[1]] + 
                         funcs.5[2,3][[1]]*Green + 
                         funcs.5[2,4][[1]]*Green^2
                         ][,Nir := funcs.5[3,2][[1]] + 
                          funcs.5[3,3][[1]]*Nir + 
                          funcs.5[3,4][[1]]*Nir^2
                          ][,Red := funcs.5[4,2][[1]] + 
                          funcs.5[4,3][[1]]*Red + 
                          funcs.5[4,4][[1]]*Red^2
                          ][,TIR1 := funcs.5[5,2][[1]] + 
                          funcs.5[5,3][[1]]*TIR1 + 
                          funcs.5[5,4][[1]]*TIR1^2]

l8corr <- refCompPre[sat == 'l8'
                     ][,Blue := funcs.8[1,2][[1]] +
                                      funcs.8[1,3][[1]]*Blue +
                                      funcs.8[1,4][[1]]*Blue^2
                       ][,Green := funcs.8[2,2][[1]] + 
                         funcs.8[2,3][[1]]*Green + 
                         funcs.8[2,4][[1]]*Green^2
                         ][,Nir := funcs.8[3,2][[1]] + 
                          funcs.8[3,3][[1]]*Nir + 
                          funcs.8[3,4][[1]]*Nir^2
                          ][,Red := funcs.8[4,2][[1]] + 
                          funcs.8[4,3][[1]]*Red + 
                          funcs.8[4,4][[1]]*Red^2
                          ][,TIR1 := funcs.8[5,2][[1]] + 
                          funcs.8[5,3][[1]]*TIR1 + 
                          funcs.8[5,4][[1]]*TIR1^2]

srCor <- refCompPre %>%
  filter(sat == 'l7') %>%
  bind_rows(l5corr) %>%
  bind_rows(l8corr)

rm(l5corr, l8corr)

srCor <- as.data.table(srCor)[,dWL := fui.hue(Red, Green, Blue)]
write_feather(srCor, 'data/processed/srCorrected_us_hydrolakes_dp_20200628.feather')
```


```{r}
srCor <- as.data.table(srCor)
refCompPre <- as.data.table(refCompPre)
correctionPlot('Blue', 'l5', refCompPre, srCor)
correctionPlot('Green', 'l5', refCompPre, srCor)
correctionPlot('Red', 'l5', refCompPre, srCor)
correctionPlot('Nir', 'l5', refCompPre, srCor)
correctionPlot('TIR1', 'l5', refCompPre, srCor)
correctionPlot('Blue', 'l8', refCompPre, srCor)
correctionPlot('Green', 'l8', refCompPre, srCor)
correctionPlot('Red', 'l8', refCompPre, srCor)
correctionPlot('Nir', 'l8', refCompPre, srCor)
correctionPlot('TIR1', 'l8', refCompPre, srCor)
```



